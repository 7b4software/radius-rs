// Code generated by machine generator; DO NOT EDIT.

use crate::avp::{AVPError, AVPType, AVP};
use crate::packet::Packet;
use crate::tag::Tag;

pub const TUNNEL_TYPE_TYPE: AVPType = 64;
pub fn delete_tunnel_type(packet: &mut Packet) {
    packet.delete(TUNNEL_TYPE_TYPE);
}
pub fn add_tunnel_type(packet: &mut Packet, tag: Option<&Tag>, value: TunnelType) {
    packet.add(AVP::from_tagged_u32(TUNNEL_TYPE_TYPE, tag, value as u32));
}
pub fn lookup_tunnel_type(packet: &Packet) -> Option<Result<(TunnelType, Tag), AVPError>> {
    packet.lookup(TUNNEL_TYPE_TYPE).map(|v| {
        let (v, t) = v.encode_tagged_u32()?;
        Ok((v as TunnelType, t))
    })
}
pub fn lookup_all_tunnel_type(packet: &Packet) -> Result<Vec<(TunnelType, Tag)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_TYPE_TYPE) {
        let (v, t) = avp.encode_tagged_u32()?;
        vec.push((v as TunnelType, t))
    }
    Ok(vec)
}

pub const TUNNEL_MEDIUM_TYPE_TYPE: AVPType = 65;
pub fn delete_tunnel_medium_type(packet: &mut Packet) {
    packet.delete(TUNNEL_MEDIUM_TYPE_TYPE);
}
pub fn add_tunnel_medium_type(packet: &mut Packet, tag: Option<&Tag>, value: TunnelMediumType) {
    packet.add(AVP::from_tagged_u32(
        TUNNEL_MEDIUM_TYPE_TYPE,
        tag,
        value as u32,
    ));
}
pub fn lookup_tunnel_medium_type(
    packet: &Packet,
) -> Option<Result<(TunnelMediumType, Tag), AVPError>> {
    packet.lookup(TUNNEL_MEDIUM_TYPE_TYPE).map(|v| {
        let (v, t) = v.encode_tagged_u32()?;
        Ok((v as TunnelMediumType, t))
    })
}
pub fn lookup_all_tunnel_medium_type(
    packet: &Packet,
) -> Result<Vec<(TunnelMediumType, Tag)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_MEDIUM_TYPE_TYPE) {
        let (v, t) = avp.encode_tagged_u32()?;
        vec.push((v as TunnelMediumType, t))
    }
    Ok(vec)
}

pub const TUNNEL_CLIENT_ENDPOINT_TYPE: AVPType = 66;
pub fn delete_tunnel_client_endpoint(packet: &mut Packet) {
    packet.delete(TUNNEL_CLIENT_ENDPOINT_TYPE);
}
pub fn add_tunnel_client_endpoint(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_CLIENT_ENDPOINT_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_client_endpoint(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_CLIENT_ENDPOINT_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_client_endpoint(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_CLIENT_ENDPOINT_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub const TUNNEL_SERVER_ENDPOINT_TYPE: AVPType = 67;
pub fn delete_tunnel_server_endpoint(packet: &mut Packet) {
    packet.delete(TUNNEL_SERVER_ENDPOINT_TYPE);
}
pub fn add_tunnel_server_endpoint(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_SERVER_ENDPOINT_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_server_endpoint(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_SERVER_ENDPOINT_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_server_endpoint(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_SERVER_ENDPOINT_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub const TUNNEL_PASSWORD_TYPE: AVPType = 69;
pub fn delete_tunnel_password(packet: &mut Packet) {
    packet.delete(TUNNEL_PASSWORD_TYPE);
}
pub fn add_tunnel_password(
    packet: &mut Packet,
    tag: Option<&Tag>,
    value: &[u8],
) -> Result<(), AVPError> {
    packet.add(AVP::from_tunnel_password(
        TUNNEL_PASSWORD_TYPE,
        tag,
        value,
        packet.get_secret(),
        packet.get_authenticator(),
    )?);
    Ok(())
}
pub fn lookup_tunnel_password(packet: &Packet) -> Option<Result<(Vec<u8>, Tag), AVPError>> {
    packet
        .lookup(TUNNEL_PASSWORD_TYPE)
        .map(|v| v.encode_tunnel_password(packet.get_secret(), packet.get_authenticator()))
}
pub fn lookup_all_tunnel_password(packet: &Packet) -> Result<Vec<(Vec<u8>, Tag)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_PASSWORD_TYPE) {
        vec.push(avp.encode_tunnel_password(packet.get_secret(), packet.get_authenticator())?)
    }
    Ok(vec)
}

pub const TUNNEL_PRIVATE_GROUP_ID_TYPE: AVPType = 81;
pub fn delete_tunnel_private_group_id(packet: &mut Packet) {
    packet.delete(TUNNEL_PRIVATE_GROUP_ID_TYPE);
}
pub fn add_tunnel_private_group_id(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_PRIVATE_GROUP_ID_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_private_group_id(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_PRIVATE_GROUP_ID_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_private_group_id(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_PRIVATE_GROUP_ID_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub const TUNNEL_ASSIGNMENT_ID_TYPE: AVPType = 82;
pub fn delete_tunnel_assignment_id(packet: &mut Packet) {
    packet.delete(TUNNEL_ASSIGNMENT_ID_TYPE);
}
pub fn add_tunnel_assignment_id(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_ASSIGNMENT_ID_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_assignment_id(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_ASSIGNMENT_ID_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_assignment_id(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_ASSIGNMENT_ID_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub const TUNNEL_PREFERENCE_TYPE: AVPType = 83;
pub fn delete_tunnel_preference(packet: &mut Packet) {
    packet.delete(TUNNEL_PREFERENCE_TYPE);
}
pub fn add_tunnel_preference(packet: &mut Packet, tag: Option<&Tag>, value: u32) {
    packet.add(AVP::from_tagged_u32(TUNNEL_PREFERENCE_TYPE, tag, value));
}
pub fn lookup_tunnel_preference(packet: &Packet) -> Option<Result<(u32, Tag), AVPError>> {
    packet
        .lookup(TUNNEL_PREFERENCE_TYPE)
        .map(|v| v.encode_tagged_u32())
}
pub fn lookup_all_tunnel_preference(packet: &Packet) -> Result<Vec<(u32, Tag)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_PREFERENCE_TYPE) {
        vec.push(avp.encode_tagged_u32()?)
    }
    Ok(vec)
}

pub const TUNNEL_CLIENT_AUTH_ID_TYPE: AVPType = 90;
pub fn delete_tunnel_client_auth_id(packet: &mut Packet) {
    packet.delete(TUNNEL_CLIENT_AUTH_ID_TYPE);
}
pub fn add_tunnel_client_auth_id(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_CLIENT_AUTH_ID_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_client_auth_id(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_CLIENT_AUTH_ID_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_client_auth_id(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_CLIENT_AUTH_ID_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub const TUNNEL_SERVER_AUTH_ID_TYPE: AVPType = 91;
pub fn delete_tunnel_server_auth_id(packet: &mut Packet) {
    packet.delete(TUNNEL_SERVER_AUTH_ID_TYPE);
}
pub fn add_tunnel_server_auth_id(packet: &mut Packet, tag: Option<&Tag>, value: &str) {
    packet.add(AVP::from_tagged_string(
        TUNNEL_SERVER_AUTH_ID_TYPE,
        tag,
        value,
    ));
}
pub fn lookup_tunnel_server_auth_id(
    packet: &Packet,
) -> Option<Result<(String, Option<Tag>), AVPError>> {
    packet
        .lookup(TUNNEL_SERVER_AUTH_ID_TYPE)
        .map(|v| v.encode_tagged_string())
}
pub fn lookup_all_tunnel_server_auth_id(
    packet: &Packet,
) -> Result<Vec<(String, Option<Tag>)>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(TUNNEL_SERVER_AUTH_ID_TYPE) {
        vec.push(avp.encode_tagged_string()?)
    }
    Ok(vec)
}

pub type TunnelMediumType = u32;
pub const TUNNEL_MEDIUM_TYPE_IP: TunnelMediumType = 1;
pub const TUNNEL_MEDIUM_TYPE_I_PV_4: TunnelMediumType = 1;
pub const TUNNEL_MEDIUM_TYPE_I_PV_6: TunnelMediumType = 2;
pub const TUNNEL_MEDIUM_TYPE_NSAP: TunnelMediumType = 3;
pub const TUNNEL_MEDIUM_TYPE_HDLC: TunnelMediumType = 4;
pub const TUNNEL_MEDIUM_TYPE_BBN_1822: TunnelMediumType = 5;
pub const TUNNEL_MEDIUM_TYPE_IEEE_802: TunnelMediumType = 6;
pub const TUNNEL_MEDIUM_TYPE_E_163: TunnelMediumType = 7;
pub const TUNNEL_MEDIUM_TYPE_E_164: TunnelMediumType = 8;
pub const TUNNEL_MEDIUM_TYPE_F_69: TunnelMediumType = 9;
pub const TUNNEL_MEDIUM_TYPE_X_121: TunnelMediumType = 10;
pub const TUNNEL_MEDIUM_TYPE_IPX: TunnelMediumType = 11;
pub const TUNNEL_MEDIUM_TYPE_APPLETALK: TunnelMediumType = 12;
pub const TUNNEL_MEDIUM_TYPE_DEC_NET_IV: TunnelMediumType = 13;
pub const TUNNEL_MEDIUM_TYPE_BANYAN_VINES: TunnelMediumType = 14;
pub const TUNNEL_MEDIUM_TYPE_E_164_NSAP: TunnelMediumType = 15;

pub type TunnelType = u32;
pub const TUNNEL_TYPE_PPTP: TunnelType = 1;
pub const TUNNEL_TYPE_L2F: TunnelType = 2;
pub const TUNNEL_TYPE_L2TP: TunnelType = 3;
pub const TUNNEL_TYPE_ATMP: TunnelType = 4;
pub const TUNNEL_TYPE_VTP: TunnelType = 5;
pub const TUNNEL_TYPE_AH: TunnelType = 6;
pub const TUNNEL_TYPE_IP: TunnelType = 7;
pub const TUNNEL_TYPE_MIN_IP: TunnelType = 8;
pub const TUNNEL_TYPE_ESP: TunnelType = 9;
pub const TUNNEL_TYPE_GRE: TunnelType = 10;
pub const TUNNEL_TYPE_DVS: TunnelType = 11;
pub const TUNNEL_TYPE_IP_IN_IP: TunnelType = 12;
