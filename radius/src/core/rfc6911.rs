// Code generated by machine generator; DO NOT EDIT.

use std::net::Ipv6Addr;

use crate::core::avp::{AVPError, AVPType, AVP};
use crate::core::packet::Packet;

pub const FRAMED_IPV6_ADDRESS_TYPE: AVPType = 168;
pub fn delete_framed_ipv6_address(packet: &mut Packet) {
    packet.delete(FRAMED_IPV6_ADDRESS_TYPE);
}
pub fn add_framed_ipv6_address(packet: &mut Packet, value: &Ipv6Addr) {
    packet.add(AVP::from_ipv6(FRAMED_IPV6_ADDRESS_TYPE, value));
}
pub fn lookup_framed_ipv6_address(packet: &Packet) -> Option<Result<Ipv6Addr, AVPError>> {
    packet
        .lookup(FRAMED_IPV6_ADDRESS_TYPE)
        .map(|v| v.encode_ipv6())
}
pub fn lookup_all_framed_ipv6_address(packet: &Packet) -> Result<Vec<Ipv6Addr>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(FRAMED_IPV6_ADDRESS_TYPE) {
        vec.push(avp.encode_ipv6()?)
    }
    Ok(vec)
}

pub const DNS_SERVER_IPV6_ADDRESS_TYPE: AVPType = 169;
pub fn delete_dns_server_ipv6_address(packet: &mut Packet) {
    packet.delete(DNS_SERVER_IPV6_ADDRESS_TYPE);
}
pub fn add_dns_server_ipv6_address(packet: &mut Packet, value: &Ipv6Addr) {
    packet.add(AVP::from_ipv6(DNS_SERVER_IPV6_ADDRESS_TYPE, value));
}
pub fn lookup_dns_server_ipv6_address(packet: &Packet) -> Option<Result<Ipv6Addr, AVPError>> {
    packet
        .lookup(DNS_SERVER_IPV6_ADDRESS_TYPE)
        .map(|v| v.encode_ipv6())
}
pub fn lookup_all_dns_server_ipv6_address(packet: &Packet) -> Result<Vec<Ipv6Addr>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(DNS_SERVER_IPV6_ADDRESS_TYPE) {
        vec.push(avp.encode_ipv6()?)
    }
    Ok(vec)
}

pub const ROUTE_IPV6_INFORMATION_TYPE: AVPType = 170;
pub fn delete_route_ipv6_information(packet: &mut Packet) {
    packet.delete(ROUTE_IPV6_INFORMATION_TYPE);
}
pub fn add_route_ipv6_information(packet: &mut Packet, value: &[u8]) -> Result<(), AVPError> {
    packet.add(AVP::from_ipv6_prefix(ROUTE_IPV6_INFORMATION_TYPE, value)?);
    Ok(())
}
pub fn lookup_route_ipv6_information(packet: &Packet) -> Option<Result<Vec<u8>, AVPError>> {
    packet
        .lookup(ROUTE_IPV6_INFORMATION_TYPE)
        .map(|v| v.encode_ipv6_prefix())
}
pub fn lookup_all_route_ipv6_information(packet: &Packet) -> Result<Vec<Vec<u8>>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(ROUTE_IPV6_INFORMATION_TYPE) {
        vec.push(avp.encode_ipv6_prefix()?)
    }
    Ok(vec)
}

pub const DELEGATED_IPV6_PREFIX_POOL_TYPE: AVPType = 171;
pub fn delete_delegated_ipv6_prefix_pool(packet: &mut Packet) {
    packet.delete(DELEGATED_IPV6_PREFIX_POOL_TYPE);
}
pub fn add_delegated_ipv6_prefix_pool(packet: &mut Packet, value: &str) {
    packet.add(AVP::from_string(DELEGATED_IPV6_PREFIX_POOL_TYPE, value));
}
pub fn lookup_delegated_ipv6_prefix_pool(packet: &Packet) -> Option<Result<String, AVPError>> {
    packet
        .lookup(DELEGATED_IPV6_PREFIX_POOL_TYPE)
        .map(|v| v.encode_string())
}
pub fn lookup_all_delegated_ipv6_prefix_pool(packet: &Packet) -> Result<Vec<String>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(DELEGATED_IPV6_PREFIX_POOL_TYPE) {
        vec.push(avp.encode_string()?)
    }
    Ok(vec)
}

pub const STATEFUL_IPV6_ADDRESS_POOL_TYPE: AVPType = 172;
pub fn delete_stateful_ipv6_address_pool(packet: &mut Packet) {
    packet.delete(STATEFUL_IPV6_ADDRESS_POOL_TYPE);
}
pub fn add_stateful_ipv6_address_pool(packet: &mut Packet, value: &str) {
    packet.add(AVP::from_string(STATEFUL_IPV6_ADDRESS_POOL_TYPE, value));
}
pub fn lookup_stateful_ipv6_address_pool(packet: &Packet) -> Option<Result<String, AVPError>> {
    packet
        .lookup(STATEFUL_IPV6_ADDRESS_POOL_TYPE)
        .map(|v| v.encode_string())
}
pub fn lookup_all_stateful_ipv6_address_pool(packet: &Packet) -> Result<Vec<String>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(STATEFUL_IPV6_ADDRESS_POOL_TYPE) {
        vec.push(avp.encode_string()?)
    }
    Ok(vec)
}
