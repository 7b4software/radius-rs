// Code generated by machine generator; DO NOT EDIT.

use std::net::Ipv6Addr;

use crate::core::avp::{AVPError, AVPType, AVP};
use crate::core::packet::Packet;

pub const NAS_IPV6_ADDRESS_TYPE: AVPType = 95;
pub fn delete_nas_ipv6_address(packet: &mut Packet) {
    packet.delete(NAS_IPV6_ADDRESS_TYPE);
}
pub fn add_nas_ipv6_address(packet: &mut Packet, value: &Ipv6Addr) {
    packet.add(AVP::from_ipv6(NAS_IPV6_ADDRESS_TYPE, value));
}
pub fn lookup_nas_ipv6_address(packet: &Packet) -> Option<Result<Ipv6Addr, AVPError>> {
    packet
        .lookup(NAS_IPV6_ADDRESS_TYPE)
        .map(|v| v.encode_ipv6())
}
pub fn lookup_all_nas_ipv6_address(packet: &Packet) -> Result<Vec<Ipv6Addr>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(NAS_IPV6_ADDRESS_TYPE) {
        vec.push(avp.encode_ipv6()?)
    }
    Ok(vec)
}

pub const FRAMED_INTERFACE_ID_TYPE: AVPType = 96;
pub fn delete_framed_interface_id(packet: &mut Packet) {
    packet.delete(FRAMED_INTERFACE_ID_TYPE);
}
pub fn add_framed_interface_id(packet: &mut Packet, value: &[u8]) -> Result<(), AVPError> {
    if value.len() != 8 {
        return Err(AVPError::InvalidAttributeLengthError(
            "8 bytes".to_owned(),
            value.len(),
        ));
    }
    packet.add(AVP::from_bytes(FRAMED_INTERFACE_ID_TYPE, value));
    Ok(())
}
pub fn lookup_framed_interface_id(packet: &Packet) -> Option<Vec<u8>> {
    packet
        .lookup(FRAMED_INTERFACE_ID_TYPE)
        .map(|v| v.encode_bytes())
}
pub fn lookup_all_framed_interface_id(packet: &Packet) -> Vec<Vec<u8>> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(FRAMED_INTERFACE_ID_TYPE) {
        vec.push(avp.encode_bytes())
    }
    vec
}

pub const FRAMED_IPV6_PREFIX_TYPE: AVPType = 97;
pub fn delete_framed_ipv6_prefix(packet: &mut Packet) {
    packet.delete(FRAMED_IPV6_PREFIX_TYPE);
}
pub fn add_framed_ipv6_prefix(packet: &mut Packet, value: &[u8]) -> Result<(), AVPError> {
    packet.add(AVP::from_ipv6_prefix(FRAMED_IPV6_PREFIX_TYPE, value)?);
    Ok(())
}
pub fn lookup_framed_ipv6_prefix(packet: &Packet) -> Option<Result<Vec<u8>, AVPError>> {
    packet
        .lookup(FRAMED_IPV6_PREFIX_TYPE)
        .map(|v| v.encode_ipv6_prefix())
}
pub fn lookup_all_framed_ipv6_prefix(packet: &Packet) -> Result<Vec<Vec<u8>>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(FRAMED_IPV6_PREFIX_TYPE) {
        vec.push(avp.encode_ipv6_prefix()?)
    }
    Ok(vec)
}

pub const LOGIN_IPV6_HOST_TYPE: AVPType = 98;
pub fn delete_login_ipv6_host(packet: &mut Packet) {
    packet.delete(LOGIN_IPV6_HOST_TYPE);
}
pub fn add_login_ipv6_host(packet: &mut Packet, value: &Ipv6Addr) {
    packet.add(AVP::from_ipv6(LOGIN_IPV6_HOST_TYPE, value));
}
pub fn lookup_login_ipv6_host(packet: &Packet) -> Option<Result<Ipv6Addr, AVPError>> {
    packet.lookup(LOGIN_IPV6_HOST_TYPE).map(|v| v.encode_ipv6())
}
pub fn lookup_all_login_ipv6_host(packet: &Packet) -> Result<Vec<Ipv6Addr>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(LOGIN_IPV6_HOST_TYPE) {
        vec.push(avp.encode_ipv6()?)
    }
    Ok(vec)
}

pub const FRAMED_IPV6_ROUTE_TYPE: AVPType = 99;
pub fn delete_framed_ipv6_route(packet: &mut Packet) {
    packet.delete(FRAMED_IPV6_ROUTE_TYPE);
}
pub fn add_framed_ipv6_route(packet: &mut Packet, value: &str) {
    packet.add(AVP::from_string(FRAMED_IPV6_ROUTE_TYPE, value));
}
pub fn lookup_framed_ipv6_route(packet: &Packet) -> Option<Result<String, AVPError>> {
    packet
        .lookup(FRAMED_IPV6_ROUTE_TYPE)
        .map(|v| v.encode_string())
}
pub fn lookup_all_framed_ipv6_route(packet: &Packet) -> Result<Vec<String>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(FRAMED_IPV6_ROUTE_TYPE) {
        vec.push(avp.encode_string()?)
    }
    Ok(vec)
}

pub const FRAMED_IPV6_POOL_TYPE: AVPType = 100;
pub fn delete_framed_ipv6_pool(packet: &mut Packet) {
    packet.delete(FRAMED_IPV6_POOL_TYPE);
}
pub fn add_framed_ipv6_pool(packet: &mut Packet, value: &str) {
    packet.add(AVP::from_string(FRAMED_IPV6_POOL_TYPE, value));
}
pub fn lookup_framed_ipv6_pool(packet: &Packet) -> Option<Result<String, AVPError>> {
    packet
        .lookup(FRAMED_IPV6_POOL_TYPE)
        .map(|v| v.encode_string())
}
pub fn lookup_all_framed_ipv6_pool(packet: &Packet) -> Result<Vec<String>, AVPError> {
    let mut vec = Vec::new();
    for avp in packet.lookup_all(FRAMED_IPV6_POOL_TYPE) {
        vec.push(avp.encode_string()?)
    }
    Ok(vec)
}
