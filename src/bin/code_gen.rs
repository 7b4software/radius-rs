use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufWriter, Write};
use std::path::Path;
use std::str::FromStr;
use std::{env, io, process};

use getopts::Options;
use inflector::Inflector;
use regex::Regex;

const ATTRIBUTE_KIND: &str = "ATTRIBUTE";
const VALUE_KIND: &str = "VALUE";

#[derive(Debug)]
struct RadiusAttribute {
    name: String,
    typ: u8,
    value_type: RadiusAttributeValueType,
    is_encrypt: bool,
}

#[derive(Debug)]
struct RadiusValue {
    name: String,
    typ: u16,
}

#[derive(Debug, PartialEq)]
enum RadiusAttributeValueType {
    String,
    UserPassword,
    Octets,
    IpAddr,
    Integer,
    VSA,
}

impl FromStr for RadiusAttributeValueType {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "string" => Ok(RadiusAttributeValueType::String),
            "octets" => Ok(RadiusAttributeValueType::Octets),
            "ipaddr" => Ok(RadiusAttributeValueType::IpAddr),
            "integer" => Ok(RadiusAttributeValueType::Integer),
            "vsa" => Ok(RadiusAttributeValueType::VSA),
            _ => Err(()),
        }
    }
}

fn print_usage(program: &str, opts: &Options) {
    let brief = format!("Usage: {} FILE [options]", program);
    print!("{}", opts.usage(&brief));
    process::exit(0);
}

fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    let matches = opts
        .parse(&args[1..])
        .unwrap_or_else(|f| panic!(f.to_string()));

    let dict_file_path = Path::new(&matches.free[0]);
    if !dict_file_path.exists() {
        panic!("no such dictionary file => {}", &matches.free[0]);
    }

    let rfc_code = dict_file_path.extension().unwrap().to_str().unwrap();
    let struct_name = rfc_code.to_uppercase();

    let (radius_attributes, radius_attribute_to_values) = parse_dict_file(dict_file_path).unwrap();

    let mut buf_writer = BufWriter::new(File::create(&matches.free[1]).unwrap());

    generate_header(&mut buf_writer, &struct_name);
    generate_attributes_code(&mut buf_writer, &radius_attributes);
    generate_footer(&mut buf_writer);
}

fn generate_header(w: &mut BufWriter<File>, struct_name: &str) {
    let code = format!(
        "// Code generated by machine generator; DO NOT EDIT.

use std::net::{{Ipv4Addr, Ipv6Addr}};

use crate::attribute::Attribute;
use crate::attributes::AVPType;
use crate::packet::Packet;

pub struct {struct_name} {{
}}
impl {struct_name} {{
    ",
        struct_name = struct_name
    );

    w.write_all(code.as_bytes()).unwrap();
}

fn generate_footer(w: &mut BufWriter<File>) {
    w.write_all(b"}\n").unwrap();
}

fn generate_attributes_code(w: &mut BufWriter<File>, attrs: &[RadiusAttribute]) {
    for attr in attrs {
        generate_attribute_code(w, attr);
    }
}

fn generate_attribute_code(w: &mut BufWriter<File>, attr: &RadiusAttribute) {
    let attr_name = attr.name.clone();
    let type_identifier = format!("{}_TYPE", attr_name.to_screaming_snake_case());
    let type_calling = format!("Self::{}", type_identifier);
    let type_value = attr.typ;
    let method_identifier = attr_name.to_snake_case();

    generate_common_attribute_code(w, &attr_name, &type_identifier, &type_calling, type_value);
    match attr.value_type {
        RadiusAttributeValueType::String => {
            generate_string_attribute_code(w, &method_identifier, &type_calling)
        }
        RadiusAttributeValueType::UserPassword => {
            generate_user_password_attribute_code(w, &method_identifier, &type_calling)
        }
        RadiusAttributeValueType::Octets => {
            generate_octets_attribute_code(w, &method_identifier, &type_calling)
        }
        RadiusAttributeValueType::IpAddr => {
            generate_ipaddr_attribute_code(w, &method_identifier, &type_calling)
        }
        RadiusAttributeValueType::Integer => {
            generate_integer_attribute_code(w, &method_identifier, &type_calling)
        }
        RadiusAttributeValueType::VSA => generate_vsa_attribute_code(),
    }
}

fn generate_common_attribute_code(
    w: &mut BufWriter<File>,
    attr_name: &str,
    type_identifier: &str,
    type_calling: &str,
    type_value: u8,
) {
    let code = format!(
        "
pub const {type_identifier}: AVPType = {type_value};
pub fn delete_{method_identifier}(packet: &mut Packet) {{
    packet.delete({type_calling});
}}
pub fn lookup_{method_identifier}(packet: &Packet) -> Option<&Attribute> {{
    packet.lookup({type_calling})
}}
pub fn lookup_all_{method_identifier}(packet: &Packet) -> Vec<&Attribute> {{
    packet.lookup_all({type_calling})
}}
",
        method_identifier = attr_name.to_snake_case(),
        type_identifier = type_identifier,
        type_calling = type_calling,
        type_value = type_value,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_string_attribute_code(
    w: &mut BufWriter<File>,
    method_identifier: &str,
    type_calling: &str,
) {
    let code = format!(
        "pub fn add_{method_identifier}(packet: &mut Packet, value: &str) {{
    let attr = Attribute::from_string(value);
    packet.add({type_calling}, &attr);
}}
",
        method_identifier = method_identifier,
        type_calling = type_calling,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_user_password_attribute_code(
    w: &mut BufWriter<File>,
    method_identifier: &str,
    type_calling: &str,
) {
    let code = format!(
        "pub fn add_{method_identifier}(packet: &mut Packet, value: &[u8]) -> Result<(), String> {{
    let attr = Attribute::from_user_password(value, packet.get_secret(), packet.get_authenticator())?;
    packet.add({type_calling}, &attr);
    Ok(())
}}
",
        method_identifier = method_identifier,
        type_calling = type_calling,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_octets_attribute_code(
    w: &mut BufWriter<File>,
    method_identifier: &str,
    type_calling: &str,
) {
    let code = format!(
        "pub fn add_{method_identifier}(packet: &mut Packet, value: &[u8]) {{
    let attr = Attribute::from_bytes(value);
    packet.add({type_calling}, &attr);
}}
",
        method_identifier = method_identifier,
        type_calling = type_calling,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_ipaddr_attribute_code(
    w: &mut BufWriter<File>,
    method_identifier: &str,
    type_calling: &str,
) {
    let code = format!(
        "pub fn add_{method_identifier}(packet: &mut Packet, value: &Ipv4Addr) {{
    let attr = Attribute::from_ipv4(value);
    packet.add({type_calling}, &attr);
}}
",
        method_identifier = method_identifier,
        type_calling = type_calling,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_integer_attribute_code(
    w: &mut BufWriter<File>,
    method_identifier: &str,
    type_calling: &str,
) {
    let code = format!(
        "pub fn add_{method_identifier}(packet: &mut Packet, value: u32) {{
    let attr = Attribute::from_u32(value);
    packet.add({type_calling}, &attr);
}}
",
        method_identifier = method_identifier,
        type_calling = type_calling,
    );
    w.write_all(code.as_bytes()).unwrap();
}

fn generate_vsa_attribute_code() {
    // NOP
}

type DictParsed = (Vec<RadiusAttribute>, HashMap<String, Vec<RadiusValue>>);

fn parse_dict_file(dict_file_path: &Path) -> Result<DictParsed, String> {
    let line_filter_re = Regex::new(r"^(?:#.*|)$").unwrap();
    let tabs_re = Regex::new(r"\t+").unwrap();

    let mut radius_attributes: Vec<RadiusAttribute> = Vec::new();
    let mut radius_attribute_to_values: HashMap<String, Vec<RadiusValue>> = HashMap::new();

    let lines = read_lines(dict_file_path).unwrap();
    for line_result in lines {
        let line = line_result.unwrap();

        if line_filter_re.is_match(line.as_str()) {
            continue;
        }

        let items = tabs_re.split(line.as_str()).collect::<Vec<&str>>();

        if items.len() < 4 {
            return Err("the number of items is lacked in a line".to_owned());
        }

        let kind = items[0];
        match kind {
            ATTRIBUTE_KIND => {
                let type_descriptions = items[3].split(' ').collect::<Vec<&str>>();

                let is_encrypt = if type_descriptions.len() >= 2 {
                    type_descriptions[1] == "encrypt=1" // FIXME: ad-hoc!!!
                } else {
                    false
                };

                let typ = match RadiusAttributeValueType::from_str(type_descriptions[0]) {
                    Ok(t) => {
                        if t == RadiusAttributeValueType::String && is_encrypt {
                            RadiusAttributeValueType::UserPassword
                        } else {
                            t
                        }
                    }
                    Err(_) => {
                        return Err(format!("invalid type has come => {}", type_descriptions[0]));
                    }
                };

                radius_attributes.push(RadiusAttribute {
                    name: items[1].to_string(),
                    typ: items[2].parse().unwrap(),
                    value_type: typ,
                    is_encrypt,
                });
            }
            VALUE_KIND => {
                let attribute_name = items[1].to_string();
                let name = items[2].to_string();

                let radius_value = RadiusValue {
                    name,
                    typ: items[3].parse().unwrap(),
                };

                match radius_attribute_to_values.get_mut(&attribute_name) {
                    None => {
                        radius_attribute_to_values
                            .insert(attribute_name.clone(), vec![radius_value]);
                    }
                    Some(vec) => {
                        vec.push(radius_value);
                    }
                };
            }
            _ => return Err(format!("unexpected kind has come => {}", kind)),
        }
    }

    Ok((radius_attributes, radius_attribute_to_values))
}
